diff -upr src.orig/VideoDriver.cpp src/VideoDriver.cpp
--- src.orig/VideoDriver.cpp	2006-08-18 11:30:11.000000000 +0200
+++ src/VideoDriver.cpp	2006-08-18 12:06:11.000000000 +0200
@@ -419,6 +419,7 @@ BOOL vncVideoDriver::Activate_NT50(
 	devmode.dmDriverExtra = 0;
 	BOOL change = EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &devmode);
 	devmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
+#if 0
 	if (prcltarget)
 	{
 // we always have to set position or
@@ -430,6 +431,7 @@ BOOL vncVideoDriver::Activate_NT50(
 		devmode.dmPelsWidth = prcltarget->right - prcltarget->left;
 		devmode.dmPelsHeight = prcltarget->bottom - prcltarget->top;
 	}
+#endif
 
 	devmode.dmDeviceName[0] = '\0';
 
diff -upr src.orig/VideoDriver.h src/VideoDriver.h
--- src.orig/VideoDriver.h	2006-08-18 11:30:11.000000000 +0200
+++ src/VideoDriver.h	2006-08-18 12:14:46.000000000 +0200
@@ -57,6 +57,7 @@ typedef enum
 } dmf_UpdEvent;
 
 
+#if 0
 #define CDS_UPDATEREGISTRY  0x00000001
 #define CDS_TEST            0x00000002
 #define CDS_FULLSCREEN      0x00000004
@@ -65,6 +66,7 @@ typedef enum
 #define CDS_RESET           0x40000000
 #define CDS_SETRECT         0x20000000
 #define CDS_NORESET         0x10000000
+#endif
 
 typedef BOOL (WINAPI* pEnumDisplayDevices)(PVOID,DWORD,PVOID,DWORD);
 typedef LONG (WINAPI* pChangeDisplaySettingsEx)(LPCTSTR, LPDEVMODE, HWND, DWORD, LPVOID);
diff -upr src.orig/vncauth.h src/vncauth.h
--- src.orig/vncauth.h	2006-08-18 11:30:11.000000000 +0200
+++ src/vncauth.h	2006-08-18 12:11:20.000000000 +0200
@@ -1,3 +1,4 @@
+#if 0
 //  Copyright (C) 1999 AT&T Laboratories Cambridge. All Rights Reserved.
 //
 //  This file is part of the VNC system.
@@ -22,6 +23,7 @@
 // If the source code for the VNC system is not available from the place 
 // whence you received this file, check http://www.uk.research.att.com/vnc or contact
 // the authors on vnc@uk.research.att.com for information on obtaining it.
+#endif
 
 
 /* 
diff -upr src.orig/vncauth_w32.c src/vncauth_w32.c
--- src.orig/vncauth_w32.c	2006-08-18 11:30:11.000000000 +0200
+++ src/vncauth_w32.c	2006-08-18 12:10:55.000000000 +0200
@@ -1,3 +1,4 @@
+#if 0
 //  Copyright (C) 1999 AT&T Laboratories Cambridge. All Rights Reserved.
 //
 //  This file is part of the VNC system.
@@ -22,6 +23,7 @@
 // If the source code for the VNC system is not available from the place 
 // whence you received this file, check http://www.uk.research.att.com/vnc or contact
 // the authors on vnc@uk.research.att.com for information on obtaining it.
+#endif
 
 
 /*
diff -upr src.orig/vncBuffer.cpp src/vncBuffer.cpp
--- src.orig/vncBuffer.cpp	2006-08-18 11:30:11.000000000 +0200
+++ src/vncBuffer.cpp	2006-08-18 12:02:47.000000000 +0200
@@ -367,6 +367,7 @@ vncBuffer::SetEncoding(CARD32 encoding)
 		tight_encoder_in_use = true;
 		break;
 
+#if 0
 	case rfbEncodingZlibHex:
 
 		vnclog.Print(LL_INTINFO, VNCLOG("ZlibHex encoder requested\n"));
@@ -386,6 +387,7 @@ vncBuffer::SetEncoding(CARD32 encoding)
 			return FALSE;
 		zlibhex_encoder_in_use = true;
 		break;
+#endif
 
 	default:
 		// An unknown encoding was specified
diff -upr src.orig/vncClient.cpp src/vncClient.cpp
--- src.orig/vncClient.cpp	2006-08-18 11:30:11.000000000 +0200
+++ src/vncClient.cpp	2006-08-18 12:01:14.000000000 +0200
@@ -203,15 +203,21 @@ vncClientThread::InitAuthenticate()
 		return FALSE;
 
 	if (m_client->m_protocol_minor_version >= 7) {
-		CARD8 list[3];
-		list[0] = (CARD8)2;					// number of security types
-		list[1] = (CARD8)secType;			// primary security type
-		list[2] = (CARD8)rfbSecTypeTight;	// support for TightVNC extensions
+		CARD8 list[2];
+		list[0] = (CARD8)1;					// number of security types
+		list[1] = (CARD8)rfbSecTypeItalc;			// primary security type
 		if (!m_socket->SendExact((char *)&list, sizeof(list)))
 			return FALSE;
 		CARD8 type;
 		if (!m_socket->ReadExact((char *)&type, sizeof(type)))
 			return FALSE;
+		if( type == rfbSecTypeItalc )
+		{
+			return( authSecTypeItalc( vsocketDispatcher,
+							m_socket,
+							ItalcAuthDSA ) );
+		}
+		return( FALSE );
 		if (type == rfbSecTypeTight) {
 			vnclog.Print(LL_INTINFO, VNCLOG("enabling TightVNC protocol extensions\n"));
 			m_client->m_protocol_tightvnc = TRUE;
@@ -301,7 +307,9 @@ vncClientThread::GetAuthenticationType()
 	}
 
 	// If necessary, query the connection with a timed dialog
+	verified = vncServer::aqrAccept;
 	BOOL skip_auth = FALSE;
+#if 0
 	if (verified == vncServer::aqrQuery) {
 		vncAcceptDialog *acceptDlg =
 			new vncAcceptDialog(m_server->QueryTimeout(),
@@ -326,6 +334,7 @@ vncClientThread::GetAuthenticationType()
 			delete acceptDlg;
 		}
 	}
+#endif
 
 	// The connection should be rejected, either due to AuthHosts settings,
 	// or because of the "Reject" action performed in the query dialog
@@ -552,12 +561,14 @@ vncClientThread::SendInteractionCaps()
 	rfbCapabilityInfo smsg_list[MAX_SMSG_CAPS];
 	i = 0;
 
+#if 0
 	if (m_server->FileTransfersEnabled() && m_client->IsInputEnabled()) {
 		SetCapInfo(&smsg_list[i++], rfbFileListData,       rfbTightVncVendor);
 		SetCapInfo(&smsg_list[i++], rfbFileDownloadData,   rfbTightVncVendor);
 		SetCapInfo(&smsg_list[i++], rfbFileUploadCancel,   rfbTightVncVendor);
 		SetCapInfo(&smsg_list[i++], rfbFileDownloadFailed, rfbTightVncVendor);
 	}
+#endif
 
 	int nServerMsgs = i;
 	if (nServerMsgs > MAX_SMSG_CAPS) {
@@ -570,6 +581,7 @@ vncClientThread::SendInteractionCaps()
 	rfbCapabilityInfo cmsg_list[MAX_CMSG_CAPS];
 	i = 0;
 
+#if 0
 	if (m_server->FileTransfersEnabled() && m_client->IsInputEnabled()) {
 		SetCapInfo(&cmsg_list[i++], rfbFileListRequest,    rfbTightVncVendor);
 		SetCapInfo(&cmsg_list[i++], rfbFileDownloadRequest,rfbTightVncVendor);
@@ -578,6 +590,7 @@ vncClientThread::SendInteractionCaps()
 		SetCapInfo(&cmsg_list[i++], rfbFileDownloadCancel, rfbTightVncVendor);
 		SetCapInfo(&cmsg_list[i++], rfbFileUploadFailed,   rfbTightVncVendor);
 	}
+#endif
 
 	int nClientMsgs = i;
 	if (nClientMsgs > MAX_CMSG_CAPS) {
@@ -1197,6 +1210,7 @@ vncClientThread::run(void *arg)
 			}
 			break;
 
+#if 0
 		case rfbFileListRequest:
 			if (!m_server->FileTransfersEnabled() || !m_client->IsInputEnabled()) {
 				connected = FALSE;
@@ -1507,6 +1521,14 @@ vncClientThread::run(void *arg)
 			}
 
 			break;
+#endif
+		case rfbItalcServiceRequest:
+			if( !processItalcClient( vsocketDispatcher, m_socket ) )
+			{
+				connected = FALSE;
+			}
+			break;
+ 
 
 		default:
 			// Unknown message, so fail!
@@ -2309,6 +2331,7 @@ vncClientThread::ConvertPath(char *path)
 void 
 vncClient::SendFileUploadCancel(unsigned short reasonLen, char *reason)
 {
+#if 0
 	omni_mutex_lock l(m_sendUpdateLock);
 
 	int msgLen = sz_rfbFileUploadCancelMsg + reasonLen;
@@ -2320,19 +2343,23 @@ vncClient::SendFileUploadCancel(unsigned
 	memcpy(pFollow, reason, reasonLen);
 	m_socket->SendExact(pAllFUCMessage, msgLen);
 	delete [] pAllFUCMessage;
+#endif
 }
 
 void 
 vncClient::Time70ToFiletime(unsigned int mTime, FILETIME *pFiletime)
 {
+#if 0
 	LONGLONG ll = Int32x32To64(mTime, 10000000) + 116444736000000000;
 	pFiletime->dwLowDateTime = (DWORD) ll;
 	pFiletime->dwHighDateTime = (DWORD)(ll >> 32);
+#endif
 }
 
 void 
 vncClient::SendFileDownloadFailed(unsigned short reasonLen, char *reason)
 {
+#if 0
 	omni_mutex_lock l(m_sendUpdateLock);
 
 	int msgLen = sz_rfbFileDownloadFailedMsg + reasonLen;
@@ -2344,11 +2371,13 @@ vncClient::SendFileDownloadFailed(unsign
 	memcpy(pFollow, reason, reasonLen);
 	m_socket->SendExact(pAllFDFMessage, msgLen);
 	delete [] pAllFDFMessage;
+#endif
 }
 
 void 
 vncClient::SendFileDownloadData(unsigned int mTime)
 {
+#if 0
 	omni_mutex_lock l(m_sendUpdateLock);
 
 	int msgLen = sz_rfbFileDownloadDataMsg + sizeof(unsigned int);
@@ -2362,11 +2391,13 @@ vncClient::SendFileDownloadData(unsigned
 	memcpy(pFollow, &mTime, sizeof(unsigned int));
 	m_socket->SendExact(pAllFDDMessage, msgLen);
 	delete [] pAllFDDMessage;
+#endif
 }
 
 void
 vncClient::SendFileDownloadPortion()
 {
+#if 0
 	if (!m_bDownloadStarted) return;
 	DWORD dwNumberOfBytesRead = 0;
 	m_rfbBlockSize = 8192;
@@ -2383,11 +2414,13 @@ vncClient::SendFileDownloadPortion()
 	SendFileDownloadData((unsigned short)dwNumberOfBytesRead, pBuff);
 	delete [] pBuff;
 	PostToWinVNC(fileTransferDownloadMessage, (WPARAM) this, (LPARAM) 0);
+#endif
 }
 
 void 
 vncClient::SendFileDownloadData(unsigned short sizeFile, char *pFile)
 {
+#if 0
 	omni_mutex_lock l(m_sendUpdateLock);
 
 	int msgLen = sz_rfbFileDownloadDataMsg + sizeFile;
@@ -2402,16 +2435,19 @@ vncClient::SendFileDownloadData(unsigned
 	m_socket->SendExact(pAllFDDMessage, msgLen);
 	delete [] pAllFDDMessage;
 
+#endif
 }
 
 unsigned int 
 vncClient::FiletimeToTime70(FILETIME filetime)
 {
+#if 0
 	LARGE_INTEGER uli;
 	uli.LowPart = filetime.dwLowDateTime;
 	uli.HighPart = filetime.dwHighDateTime;
 	uli.QuadPart = (uli.QuadPart - 116444736000000000) / 10000000;
 	return uli.LowPart;
+#endif
 }
 
 void
Nur in src: vncClient.cpp.orig.
Nur in src: vncClient.cpp.rej.
diff -upr src.orig/vncClient.h src/vncClient.h
--- src.orig/vncClient.h	2006-08-18 11:30:11.000000000 +0200
+++ src/vncClient.h	2006-08-18 12:13:40.000000000 +0200
@@ -64,7 +64,7 @@ class vncClient
 public:
 	// Constructor/destructor
 	vncClient();
-	~vncClient();
+	virtual ~vncClient();
 
 	// Allow the client thread to see inside the client object
 	friend class vncClientThread;
Nur in src: vncClient.h.orig.
Nur in src: vncClient.h.rej.
diff -upr src.orig/vncDesktop.cpp src/vncDesktop.cpp
--- src.orig/vncDesktop.cpp	2006-08-18 11:30:11.000000000 +0200
+++ src/vncDesktop.cpp	2006-08-18 12:24:41.000000000 +0200
@@ -33,7 +33,7 @@
 
 // Custom headers
 #include "WinVNC.h"
-#include "VNCHooks\VNCHooks.h"
+#include "VNCHooks.h"
 #include "vncServer.h"
 #include "vncRegion.h"
 #include "rectlist.h"
@@ -58,8 +58,10 @@ const UINT RFB_LOCAL_MOUSE = RegisterWin
 const char szDesktopSink[] = "WinVNC desktop sink";
 
 // Atoms
+#if 0
 const char *VNC_WINDOWPOS_ATOMNAME = "VNCHooks.CopyRect.WindowPos";
 ATOM VNC_WINDOWPOS_ATOM = NULL;
+#endif
 
 // Static members to use with new polling algorithm
 const int vncDesktop::m_pollingOrder[32] = {
@@ -1379,7 +1381,7 @@ vncDesktop::FillDisplayInfo(rfbServerIni
 // Function to capture an area of the screen immediately prior to sending
 // an update.
 
-void vncDesktop::CaptureScreen(RECT &UpdateArea, BYTE *scrBuff)
+void vncDesktop::CaptureScreen(const RECT &UpdateArea, BYTE *scrBuff)
 {
 // ASSUME rect related to virtual desktop
 	if (m_videodriver && m_videodriver->IsDirectAccessInEffect())
diff -upr src.orig/vncDesktop.h src/vncDesktop.h
--- src.orig/vncDesktop.h	2006-08-18 11:30:11.000000000 +0200
+++ src/vncDesktop.h	2006-08-18 12:04:18.000000000 +0200
@@ -86,7 +86,7 @@ public:
 	void FillDisplayInfo(rfbServerInitMsg *scrInfo);
 	void SetLocalInputDisableHook(BOOL enable);
 	void SetLocalInputPriorityHook(BOOL enable);
-	void CaptureScreen(RECT &UpdateArea, BYTE *scrBuff);
+	void CaptureScreen(const RECT &UpdateArea, BYTE *scrBuff);
 	void CaptureScreenFromAdapterGeneral(RECT UpdateArea, BYTE *scrBuff);
 	void CaptureScreenFromMirage(RECT UpdateArea, BYTE *scrBuff);
 	int ScreenBuffSize();
@@ -145,7 +145,7 @@ protected:
 	BOOL InitHooks();
 	BOOL SetPalette();
 
-	void CopyToBuffer(RECT rect, BYTE *scrBuff);
+	void CopyToBuffer(const RECT rect, BYTE *scrBuff);
 	void CopyToBuffer(RECT rect, BYTE *scrBuff, const BYTE *SourceBuff);
 	void CopyRectToBuffer(RECT dest, POINT source);
 	void CalcCopyRects();
@@ -188,10 +188,11 @@ protected:
 	void BlankScreen(BOOL set);
 
 	// Timer identifiers (the third one is not used in any real timer)
-	enum TimerID {
+	struct TimerID { enum {
 		POLL = 1,
 		BLANK_SCREEN = 2,
 		RESTORE_SCREEN = 3
+		} ;
 	};
 
 	// Video driver stuff
diff -upr src.orig/vncEncoder.cpp src/vncEncoder.cpp
--- src.orig/vncEncoder.cpp	2006-08-18 11:30:11.000000000 +0200
+++ src/vncEncoder.cpp	2006-08-18 12:01:50.000000000 +0200
@@ -140,8 +140,8 @@ vncEncoder::Translate(BYTE *source, BYTE
 inline UINT
 vncEncoder::EncodeRect(BYTE *source, BYTE *dest, const RECT &rect, int offsetx, int offsety)
 {
-	const rectW = rect.right - rect.left;
-	const rectH = rect.bottom - rect.top;
+	const int rectW = rect.right - rect.left;
+	const int rectH = rect.bottom - rect.top;
 
 	// Create the header for the update in the destination area
 	rfbFramebufferUpdateRectHeader *surh = (rfbFramebufferUpdateRectHeader *)dest;
diff -upr src.orig/vncEncodeTight.cpp src/vncEncodeTight.cpp
--- src.orig/vncEncodeTight.cpp	2006-08-18 11:30:11.000000000 +0200
+++ src/vncEncodeTight.cpp	2006-08-18 12:15:48.000000000 +0200
@@ -1455,7 +1455,7 @@ vncEncodeTight::SendJpegRect(BYTE *dst, 
 	jpeg_set_defaults(&cinfo);
 	jpeg_set_quality(&cinfo, quality, TRUE);
 
-	JpegSetDstManager (&cinfo, dst, w * h * (m_localformat.bitsPerPixel / 8));
+	JpegSetDstManager (&cinfo, (JOCTET*)dst, w * h * (m_localformat.bitsPerPixel / 8));
 
 	jpeg_start_compress(&cinfo, TRUE);
 
diff -upr src.orig/vncEncodeZlib.cpp src/vncEncodeZlib.cpp
--- src.orig/vncEncodeZlib.cpp	2006-08-18 11:30:11.000000000 +0200
+++ src/vncEncodeZlib.cpp	2006-08-18 12:12:57.000000000 +0200
@@ -86,8 +86,8 @@ vncEncodeZlib::NumCodedRects(RECT &rect)
 	return 1;
 ******************************************************************/
 
-	const rectW = rect.right - rect.left;
-	const rectH = rect.bottom - rect.top;
+	const int rectW = rect.right - rect.left;
+	const int rectH = rect.bottom - rect.top;
 
 	// Return the number of rectangles needed to encode the given
 	// update.  ( ZLIB_MAX_SIZE(rectW) / rectW ) is the number of lines in 
@@ -114,8 +114,8 @@ vncEncodeZlib::EncodeRect(BYTE *source, 
 	offsety = offy;
 	RECT partialRect;
 
-	const rectW = rect.right - rect.left;
-	const rectH = rect.bottom - rect.top;
+	const int rectW = rect.right - rect.left;
+	const int rectH = rect.bottom - rect.top;
 
 	partialRect.right = rect.right;
 	partialRect.left = rect.left;
@@ -172,10 +172,10 @@ vncEncodeZlib::EncodeOneRect(BYTE *sourc
 	int previousTotalOut;
 	int deflateResult;
 
-	const rectW = rect.right - rect.left;
-	const rectH = rect.bottom - rect.top;
-	const rawDataSize = (rectW*rectH*m_remoteformat.bitsPerPixel / 8);
-	const maxCompSize = (rawDataSize + (rawDataSize/100) + 8);
+	const int rectW = rect.right - rect.left;
+	const int rectH = rect.bottom - rect.top;
+	const int rawDataSize = (rectW*rectH*m_remoteformat.bitsPerPixel / 8);
+	const int maxCompSize = (rawDataSize + (rawDataSize/100) + 8);
 
 	// Send as raw if the update is too small to compress.
 	if (rawDataSize < VNC_ENCODE_ZLIB_MIN_COMP_SIZE)
diff -upr src.orig/vncServer.cpp src/vncServer.cpp
--- src.orig/vncServer.cpp	2006-08-18 11:30:11.000000000 +0200
+++ src/vncServer.cpp	2006-08-18 11:44:24.000000000 +0200
@@ -88,7 +88,7 @@ vncServer::vncServer()
 	m_driver_direct_access_en = TRUE;
 
 	// General options
-	m_loopbackOnly = FALSE;
+	m_loopbackOnly = TRUE;
 	m_disableTrayIcon = FALSE;
 	m_loopback_allowed = FALSE;
 	m_httpd_enabled = TRUE;
@@ -149,6 +149,7 @@ vncServer::~vncServer()
 		m_socketConn = NULL;
 	}
 
+#if 0
 	if (m_corbaConn != NULL)
 	{
 		delete m_corbaConn;
@@ -160,6 +161,7 @@ vncServer::~vncServer()
 		delete m_httpConn;
 		m_httpConn = NULL;
 	}
+#endif
 
 	// Remove any active clients!
 	KillAuthClients();
@@ -995,6 +997,7 @@ vncServer::SockConnect(BOOL On)
 				}
 			}
 
+#if 0
 			// Now let's start the HTTP connection stuff
 			if (m_port_http == m_port) {
 				vnclog.Print(LL_INTERR, VNCLOG("cannot start both RFB and HTTP servers "
@@ -1012,6 +1015,7 @@ vncServer::SockConnect(BOOL On)
 					}
 				}
 			}
+#endif
 		}
 	}
 	else
@@ -1032,6 +1036,7 @@ vncServer::SockConnect(BOOL On)
 			m_socketConn = NULL;
 		}
 
+#if 0
 		// Is there an HTTP socket active?
 		if (m_httpConn != NULL)
 		{
@@ -1039,6 +1044,7 @@ vncServer::SockConnect(BOOL On)
 			delete m_httpConn;
 			m_httpConn = NULL;
 		}
+#endif
 	}
 
 	return TRUE;
@@ -1053,6 +1059,7 @@ vncServer::SockConnected()
 BOOL
 vncServer::SetHttpdEnabled(BOOL enable_httpd, BOOL enable_params)
 {
+#if 0
 	if (enable_httpd != m_httpd_enabled) {
 		m_httpd_enabled = enable_httpd;
 		m_httpd_params_enabled = enable_params;
@@ -1068,6 +1075,7 @@ vncServer::SetHttpdEnabled(BOOL enable_h
 			}
 		}
 	}
+#endif
 	return TRUE;
 }
 
@@ -1110,6 +1118,7 @@ vncServer::GetDisableTrayIcon()
 BOOL
 vncServer::CORBAConnect(BOOL On)
 {
+#if 0
 	// Are we being asked to switch CORBA connects on or off?
 	if (On)
 	{
@@ -1137,7 +1146,7 @@ vncServer::CORBAConnect(BOOL On)
 			m_corbaConn = NULL;
 		}
 	}
-
+#endif
 	return TRUE;
 }
 
diff -upr src.orig/vncServer.h src/vncServer.h
--- src.orig/vncServer.h	2006-08-18 11:30:11.000000000 +0200
+++ src/vncServer.h	2006-08-18 12:13:28.000000000 +0200
@@ -68,7 +68,7 @@ class vncServer
 public:
 	// Constructor/destructor
 	vncServer();
-	~vncServer();
+	virtual ~vncServer();
 
 	// Client handling functions
 	virtual void DisableClients(BOOL state);
diff -upr src.orig/vncService.cpp src/vncService.cpp
--- src.orig/vncService.cpp	2006-08-18 11:30:11.000000000 +0200
+++ src/vncService.cpp	2006-08-18 11:41:42.000000000 +0200
@@ -223,6 +223,7 @@ vncService::VersionMinor()
 BOOL
 PostToWinVNC(UINT message, WPARAM wParam, LPARAM lParam)
 {
+#if 0
 	// Locate the hidden WinVNC menu window
 	HWND hservwnd = FindWindow(MENU_CLASS_NAME, NULL);
 	if (hservwnd == NULL)
@@ -230,6 +231,8 @@ PostToWinVNC(UINT message, WPARAM wParam
 
 	// Post the message to WinVNC
 	PostMessage(hservwnd, message, wParam, lParam);
+#endif
+
 	return TRUE;
 }
 
@@ -532,12 +535,14 @@ vncService::FindWindowByTitle(char *subs
 BOOL
 vncService::PostShareAll()
 {
+#if 0
 	// Post to the WinVNC menu window
 	if (!PostToWinVNC(MENU_SERVER_SHAREALL, 0, 0))
 	{
 		MessageBox(NULL, "No existing instance of WinVNC could be contacted", szAppName, MB_ICONEXCLAMATION | MB_OK);
 		return FALSE;
 	}
+#endif
 
 	return TRUE;
 }
@@ -545,12 +550,14 @@ vncService::PostShareAll()
 BOOL
 vncService::PostSharePrimary()
 {
+#if 0
 	// Post to the WinVNC menu window
 	if (!PostToWinVNC(MENU_SERVER_SHAREPRIMARY, 0, 0))
 	{
 		MessageBox(NULL, "No existing instance of WinVNC could be contacted", szAppName, MB_ICONEXCLAMATION | MB_OK);
 		return FALSE;
 	}
+#endif
 
 	return TRUE;
 }
@@ -559,12 +566,14 @@ BOOL
 vncService::PostShareArea(unsigned short x, unsigned short y,
 						  unsigned short w, unsigned short h)
 {
+#if 0
 	// Post to the WinVNC menu window
 	if (!PostToWinVNC(MENU_SERVER_SHAREAREA,
 					  MAKEWPARAM(x,y), MAKELPARAM(w,h))) {
 		MessageBox(NULL, "No existing instance of WinVNC could be contacted", szAppName, MB_ICONEXCLAMATION | MB_OK);
 		return FALSE;
 	}
+#endif
 
 	return TRUE;
 }
@@ -572,12 +581,14 @@ vncService::PostShareArea(unsigned short
 BOOL
 vncService::PostShareWindow(HWND hwnd)
 {
+#if 0
 	// Post to the WinVNC menu window
 	if (!PostToWinVNC(MENU_SERVER_SHAREWINDOW, (WPARAM)hwnd, 0))
 	{
 		MessageBox(NULL, "No existing instance of WinVNC could be contacted", szAppName, MB_ICONEXCLAMATION | MB_OK);
 		return FALSE;
 	}
+#endif
 
 	return TRUE;
 }
@@ -694,6 +705,7 @@ vncService::RunningAsService()
 BOOL
 vncService::KillRunningCopy()
 {
+#if 0
 	// Locate the hidden WinVNC menu window
 	HWND hservwnd;
 
@@ -704,7 +716,7 @@ vncService::KillRunningCopy()
 
 		omni_thread::sleep(1);
 	}
-
+#endif
 	return TRUE;
 }
 
diff -upr src.orig/vncSockConnect.h src/vncSockConnect.h
--- src.orig/vncSockConnect.h	2006-08-18 11:30:11.000000000 +0200
+++ src/vncSockConnect.h	2006-08-18 12:13:20.000000000 +0200
@@ -49,7 +49,7 @@ class vncSockConnect
 public:
 	// Constructor/destructor
 	vncSockConnect();
-	~vncSockConnect();
+	virtual ~vncSockConnect();
 
 	// Init
 	virtual VBool Init(vncServer *server, UINT port);
diff -upr src.orig/vncTimedMsgBox.h src/vncTimedMsgBox.h
--- src.orig/vncTimedMsgBox.h	2006-08-18 11:30:11.000000000 +0200
+++ src/vncTimedMsgBox.h	2006-08-18 12:31:20.000000000 +0200
@@ -37,7 +37,7 @@ class vncTimedMsgBox
 {
 public:
 	// Bring up a message box, wait for two seconds, then return
-	static void Do(const char *caption, const char *title, UINT type);
+	static inline void Do(const char *caption, const char *title, UINT type) { }
 };
 
 #endif
diff -upr src.orig/WinVNC.cpp src/WinVNC.cpp
--- src.orig/WinVNC.cpp	2006-08-18 11:30:11.000000000 +0200
+++ src/WinVNC.cpp	2006-08-18 11:40:04.000000000 +0200
@@ -50,6 +50,7 @@ const char	*szAppName = "WinVNC";
 
 DWORD		mainthreadId;
 
+#if 0
 // WinMain parses the command line and either calls the main App
 // routine or, under NT, the main service routine.
 int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
@@ -349,6 +350,7 @@ int WINAPI WinMain(HINSTANCE hInstance, 
 
 	return 0;
 }
+#endif
 
 // This is the main routine for WinVNC when running as an application
 // (under Windows 95 or Windows NT)
@@ -374,8 +376,10 @@ int WinVNCAppMain()
 
 	// Set the name and port number
 	server.SetName(szAppName);
+	server.SockConnect( TRUE );
 	vnclog.Print(LL_STATE, VNCLOG("server created ok\n"));
 
+#if 0
 	// Create tray icon & menu if we're running as an app
 	vncMenu *menu = new vncMenu(&server);
 	if (menu == NULL)
@@ -383,6 +387,7 @@ int WinVNCAppMain()
 		vnclog.Print(LL_INTERR, VNCLOG("failed to create tray menu\n"));
 		PostQuitMessage(0);
 	}
+#endif
 
 	// Now enter the message handling loop until told to quit!
 	MSG msg;
@@ -394,8 +399,10 @@ int WinVNCAppMain()
 
 	vnclog.Print(LL_STATE, VNCLOG("shutting down server\n"));
 
+#if 0
 	if (menu != NULL)
 		delete menu;
+#endif
 
 	return msg.wParam;
 }
